;; Lowering-specific parts of the prelude.

;; Instruction creation helpers ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Emit an instruction.
;;
;; This is low-level and side-effectful; it should only be used as an
;; implementation detail by helpers that preserve the SSA facade themselves.

(decl emit (MInst) Unit)
(extern constructor emit emit)

;; Constant pool emission.

(type VCodeConstant (primitive VCodeConstant))

;; MachInst-level atomic ops.
(type MachAtomicRmwOp extern (enum))

;; Put the given value into a register.
;;
;; Asserts that the value fits into a single register, and doesn't require
;; multiple registers for its representation (like `i128` on x64 for example).
;;
;; As a side effect, this marks the value as used.
(decl put_in_reg (Value) Reg)
(extern constructor put_in_reg put_in_reg)

;; Put the given value into one or more registers.
;;
;; As a side effect, this marks the value as used.
(decl put_in_regs (Value) ValueRegs)
(extern constructor put_in_regs put_in_regs)

;; If the given reg is a real register, cause the value in reg to be in a virtual
;; reg, by copying it into a new virtual reg.
(decl ensure_in_vreg (Reg Type) Reg)
(extern constructor ensure_in_vreg ensure_in_vreg)

;; Add a u64 little-endian constant to the in-memory constant pool and
;; return a VCodeConstant index that refers to it. This is
;; side-effecting but idempotent (constants are deduplicated).
(decl emit_u64_le_const (u64) VCodeConstant)
(extern constructor emit_u64_le_const emit_u64_le_const)

;;;; Helpers for Side-Effectful Instructions Without Results ;;;;;;;;;;;;;;;;;;;

(type SideEffectNoResult (enum
                          (Inst (inst MInst))
                          (Inst2 (inst1 MInst)
                                 (inst2 MInst))))

;; Create an empty `InstOutput`, but do emit the given side-effectful
;; instruction.
(decl side_effect (SideEffectNoResult) InstOutput)
(rule (side_effect (SideEffectNoResult.Inst inst))
      (let ((_ Unit (emit inst)))
        (output_none)))
(rule (side_effect (SideEffectNoResult.Inst2 inst1 inst2))
      (let ((_1 Unit (emit inst1))
            (_2 Unit (emit inst2)))
        (output_none)))

(decl side_effect_concat (SideEffectNoResult SideEffectNoResult) SideEffectNoResult)
(rule (side_effect_concat (SideEffectNoResult.Inst inst1) (SideEffectNoResult.Inst inst2))
      (SideEffectNoResult.Inst2 inst1 inst2))

;;;; Helpers for Working with Flags ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Newtype wrapper around `MInst` for instructions that are used for their
;; effect on flags.
;;
;; Variant determines how result is given when combined with a
;; ConsumesFlags. See `with_flags` below for more.
(type ProducesFlags (enum
                     (ProducesFlagsSideEffect (inst MInst))
                     ;; Not directly combinable with a ConsumesFlags;
                     ;; used in s390x and unwrapped directly by `trapif`.
                     (ProducesFlagsReturnsReg (inst MInst) (result Reg))
                     (ProducesFlagsReturnsResultWithConsumer (inst MInst) (result Reg))))

;; Newtype wrapper around `MInst` for instructions that consume flags.
;;
;; Variant determines how result is given when combined with a
;; ProducesFlags. See `with_flags` below for more.
(type ConsumesFlags (enum
                     (ConsumesFlagsReturnsResultWithProducer (inst MInst) (result Reg))
                     (ConsumesFlagsReturnsReg (inst MInst) (result Reg))
                     (ConsumesFlagsTwiceReturnsValueRegs (inst1 MInst)
                                                         (inst2 MInst)
                                                         (result ValueRegs))
                     (ConsumesFlagsFourTimesReturnsValueRegs (inst1 MInst)
                                                             (inst2 MInst)
                                                             (inst3 MInst)
                                                             (inst4 MInst)
                                                             (result ValueRegs))))



;; Get the produced register out of a ProducesFlags.
(decl produces_flags_get_reg (ProducesFlags) Reg)
(rule (produces_flags_get_reg (ProducesFlags.ProducesFlagsReturnsReg _ reg)) reg)

;; Modify a ProducesFlags to use it only for its side-effect, ignoring
;; its result.
(decl produces_flags_ignore (ProducesFlags) ProducesFlags)
(rule (produces_flags_ignore (ProducesFlags.ProducesFlagsReturnsReg inst _))
                             (ProducesFlags.ProducesFlagsSideEffect inst))
(rule (produces_flags_ignore (ProducesFlags.ProducesFlagsReturnsResultWithConsumer inst _))
                             (ProducesFlags.ProducesFlagsSideEffect inst))

;; Helper for combining two flags-consumer instructions that return a
;; single Reg, giving a ConsumesFlags that returns both values in a
;; ValueRegs.
(decl consumes_flags_concat (ConsumesFlags ConsumesFlags) ConsumesFlags)
(rule (consumes_flags_concat (ConsumesFlags.ConsumesFlagsReturnsReg inst1 reg1)
                             (ConsumesFlags.ConsumesFlagsReturnsReg inst2 reg2))
      (ConsumesFlags.ConsumesFlagsTwiceReturnsValueRegs
       inst1
       inst2
       (value_regs reg1 reg2)))

;; Combine flags-producing and -consuming instructions together, ensuring that
;; they are emitted back-to-back and no other instructions can be emitted
;; between them and potentially clobber the flags.
;;
;; Returns a `ValueRegs` according to the specific combination of ProducesFlags and ConsumesFlags modes:
;; - SideEffect + ReturnsReg --> ValueReg with one Reg from consumer
;; - SideEffect + ReturnsValueRegs --> ValueReg as given from consumer
;; - ReturnsResultWithProducer + ReturnsResultWithConsumer --> ValueReg with low part from producer, high part from consumer
;;
;; See `with_flags_reg` below for a variant that extracts out just the lower Reg.
(decl with_flags (ProducesFlags ConsumesFlags) ValueRegs)

(rule (with_flags (ProducesFlags.ProducesFlagsReturnsResultWithConsumer producer_inst producer_result)
                  (ConsumesFlags.ConsumesFlagsReturnsResultWithProducer consumer_inst consumer_result))
      (let ((_x Unit (emit producer_inst))
            (_y Unit (emit consumer_inst)))
        (value_regs producer_result consumer_result)))

(rule (with_flags (ProducesFlags.ProducesFlagsSideEffect producer_inst)
                  (ConsumesFlags.ConsumesFlagsReturnsReg consumer_inst consumer_result))
      (let ((_x Unit (emit producer_inst))
            (_y Unit (emit consumer_inst)))
        (value_reg consumer_result)))

(rule (with_flags (ProducesFlags.ProducesFlagsSideEffect producer_inst)
                  (ConsumesFlags.ConsumesFlagsTwiceReturnsValueRegs consumer_inst_1
                                                                    consumer_inst_2
                                                                    consumer_result))
      ;; We must emit these instructions in order as the creator of
      ;; the ConsumesFlags may be relying on dataflow dependencies
      ;; amongst them.
      (let ((_x Unit (emit producer_inst))
            (_y Unit (emit consumer_inst_1))
            (_z Unit (emit consumer_inst_2)))
        consumer_result))

(rule (with_flags (ProducesFlags.ProducesFlagsSideEffect producer_inst)
                  (ConsumesFlags.ConsumesFlagsFourTimesReturnsValueRegs consumer_inst_1
                                                                        consumer_inst_2
                                                                        consumer_inst_3
                                                                        consumer_inst_4
                                                                        consumer_result))
      ;; We must emit these instructions in order as the creator of
      ;; the ConsumesFlags may be relying on dataflow dependencies
      ;; amongst them.
      (let ((_x Unit (emit producer_inst))
            (_y Unit (emit consumer_inst_1))
            (_z Unit (emit consumer_inst_2))
            (_w Unit (emit consumer_inst_3))
            (_v Unit (emit consumer_inst_4)))
        consumer_result))

(decl with_flags_reg (ProducesFlags ConsumesFlags) Reg)
(rule (with_flags_reg p c)
      (let ((v ValueRegs (with_flags p c)))
        (value_regs_get v 0)))

;;;; Registers ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(type Reg (primitive Reg))
(type WritableReg (primitive WritableReg))
(type OptionWritableReg (primitive OptionWritableReg))
(type VecReg extern (enum))
(type VecWritableReg extern (enum))

;; Construct a `ValueRegs` of one register.
(decl value_reg (Reg) ValueRegs)
(extern constructor value_reg value_reg)

;; Construct a `ValueRegs` of two registers.
(decl value_regs (Reg Reg) ValueRegs)
(extern constructor value_regs value_regs)

;; Construct an empty `ValueRegs` containing only invalid register sentinels.
(decl value_regs_invalid () ValueRegs)
(extern constructor value_regs_invalid value_regs_invalid)

;; Construct an empty `InstOutput`.
(decl output_none () InstOutput)
(extern constructor output_none output_none)

;; Construct a single-element `InstOutput`.
(decl output (ValueRegs) InstOutput)
(extern constructor output output)

;; Construct a two-element `InstOutput`.
(decl output_pair (ValueRegs ValueRegs) InstOutput)
(extern constructor output_pair output_pair)

;; Construct a single-element `InstOutput` from a single register.
(decl output_reg (Reg) InstOutput)
(rule (output_reg reg) (output (value_reg reg)))

;; Construct a single-element `InstOutput` from a value.
(decl output_value (Value) InstOutput)
(rule (output_value val) (output (put_in_regs val)))

;; Initially empty `InstOutput` builder.
(decl output_builder_new () InstOutputBuilder)
(extern constructor output_builder_new output_builder_new)

;; Append a `ValueRegs` to an `InstOutput` under construction.
(decl output_builder_push (InstOutputBuilder ValueRegs) Unit)
(extern constructor output_builder_push output_builder_push)

;; Finish building an `InstOutput` incrementally.
(decl output_builder_finish (InstOutputBuilder) InstOutput)
(extern constructor output_builder_finish output_builder_finish)

;; Get a temporary register for writing.
(decl temp_writable_reg (Type) WritableReg)
(extern constructor temp_writable_reg temp_writable_reg)

;; Get a temporary register for reading.
(decl temp_reg (Type) Reg)
(rule (temp_reg ty)
      (writable_reg_to_reg (temp_writable_reg ty)))

;; Get or match the invalid register.
(decl invalid_reg () Reg)
(extern constructor invalid_reg invalid_reg)
(extern extractor invalid_reg invalid_reg_etor)

;; Match any register but the invalid register.
(decl valid_reg () Reg)
(extern extractor valid_reg valid_reg)

;; Get the `n`th register inside a `ValueRegs`.
(decl value_regs_get (ValueRegs usize) Reg)
(extern constructor value_regs_get value_regs_get)

;; Put the value into one or more registers and return the first register.
;;
;; Unlike `put_in_reg`, this does not assert that the value fits in a single
;; register. This is useful for things like a `i128` shift amount, where we mask
;; the shift amount to the bit width of the value being shifted, and so the high
;; half of the `i128` won't ever be used.
;;
;; As a side efect, this marks that value as used.
(decl lo_reg (Value) Reg)
(rule (lo_reg val)
      (let ((regs ValueRegs (put_in_regs val)))
        (value_regs_get regs 0)))

;; Turn a `Writable<Reg>` into a `Reg` via `Writable::to_reg`.
(decl writable_reg_to_reg (WritableReg) Reg)
(extern constructor writable_reg_to_reg writable_reg_to_reg)

(type ValueRegs (primitive ValueRegs))

;; Instruction lowering result: a vector of `ValueRegs`.
(type InstOutput (primitive InstOutput))
;; (Mutable) builder to incrementally construct an `InstOutput`.
(type InstOutputBuilder extern (enum))

;; Accessor for `GlobalValue`.

(decl symbol_value_data (ExternalName RelocDistance i64) GlobalValue)
(extern extractor symbol_value_data symbol_value_data)

;;;; Common Mach Types ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(type MachLabel (primitive MachLabel))
(type VecMachLabel extern (enum))
(type ValueLabel (primitive ValueLabel))
(type UnwindInst (primitive UnwindInst))

;; Implicit conversions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(convert Value Reg put_in_reg)
(convert Value ValueRegs put_in_regs)
(convert Reg ValueRegs value_reg)
(convert WritableReg Reg writable_reg_to_reg)
(convert ValueRegs InstOutput output)
(convert Reg InstOutput output_reg)
(convert Value InstOutput output_value)
