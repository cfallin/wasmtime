//! Represents information relating to function unwinding.

use regalloc::RealReg;

#[cfg(feature = "enable-serde")]
use serde::{Deserialize, Serialize};

#[cfg(feature = "unwind")]
pub mod systemv;

#[cfg(feature = "unwind")]
pub mod winx64;

/// Represents unwind information for a single function.
#[derive(Clone, Debug, PartialEq, Eq)]
#[cfg_attr(feature = "enable-serde", derive(Serialize, Deserialize))]
#[non_exhaustive]
pub enum UnwindInfo {
    /// Windows x64 ABI unwind information.
    #[cfg(feature = "unwind")]
    WindowsX64(winx64::UnwindInfo),
    /// System V ABI unwind information.
    #[cfg(feature = "unwind")]
    SystemV(systemv::UnwindInfo),
}

/// Intermediate representation for the unwind information
/// generated by a backend.
pub mod input {
    use crate::binemit::CodeOffset;
    use alloc::vec::Vec;
    #[cfg(feature = "enable-serde")]
    use serde::{Deserialize, Serialize};

    /// Elementary operation in the unwind operations.
    #[derive(Clone, Debug, PartialEq, Eq)]
    #[cfg_attr(feature = "enable-serde", derive(Serialize, Deserialize))]
    pub enum UnwindCode<Reg> {
        /// Defines that a register is saved at the specified offset.
        SaveRegister {
            /// The saved register.
            reg: Reg,
            /// The specified offset relative to the stack pointer.
            stack_offset: u32,
        },
        /// Defines that a register is as defined before call.
        RestoreRegister {
            /// The restored register.
            reg: Reg,
        },
        /// The stack pointer was adjusted to allocate the stack.
        StackAlloc {
            /// Size to allocate.
            size: u32,
        },
        /// The stack pointer was adjusted to free the stack.
        StackDealloc {
            /// Size to deallocate.
            size: u32,
        },
        /// The alternative register was assigned as frame pointer base.
        SetFramePointer {
            /// The specified register.
            reg: Reg,
        },
        /// Restores a frame pointer base to default register.
        RestoreFramePointer,
        /// Saves the state.
        RememberState,
        /// Restores the state.
        RestoreState,
    }

    /// Unwind information as generated by a backend.
    #[derive(Clone, Debug, PartialEq, Eq)]
    #[cfg_attr(feature = "enable-serde", derive(Serialize, Deserialize))]
    pub struct UnwindInfo<Reg> {
        /// Size of the prologue.
        pub prologue_size: CodeOffset,
        /// Unwind codes for prologue.
        pub prologue_unwind_codes: Vec<(CodeOffset, UnwindCode<Reg>)>,
        /// Unwind codes for epilogues.
        pub epilogues_unwind_codes: Vec<Vec<(CodeOffset, UnwindCode<Reg>)>>,
        /// Entire function size.
        pub function_size: CodeOffset,
        /// Platform word size in bytes.
        pub word_size: u8,
        /// Initial stack pointer offset.
        pub initial_sp_offset: u8,
    }
}

/// Unwind pseudoinstruction used in VCode backends: represents that
/// at the present location, an action has just been taken.
///
/// VCode backends always emit unwind info that is relative to a frame
/// pointer, because we are planning to allow for dynamic frame allocation,
/// and because it makes the design quite a lot simpler in general: we don't
/// have to be precise about SP adjustments throughout the body of the function.
///
/// We also emit information for prologues, but not for epilogues. This is
/// because we do not expect (for now) any unwinds to originate from within
/// epilogue code; our epilogues are short and atomic, with no stack checks,
/// destructor invocations, or the like.
///
/// Unwind pseudoinstructions are emitted inline by ABI code as it generates
/// a prologue.
///
/// Thus, for the usual case, a prologue might look like (using x64 as
/// an example):
///
/// ```plain
/// push rbp
/// mov rbp, rsp
/// unwind CreateFPFrame (BP=sp; [BP] = oldBP)
/// sub rsp, 32
/// mov [rsp+0], r12
/// unwind SaveReg [BP-32], r12
/// mov [rsp+8], r13
/// unwind SaveReg [BP-24], r13
/// ...
/// ```
#[derive(Clone, Debug, PartialEq, Eq)]
#[cfg_attr(feature = "enable-serde", derive(Serialize, Deserialize))]
pub enum UnwindInst {
    /// The frame-pointer register for this architecture has just been
    /// pushed to the stack. The FP has not been set to this frame yet.
    PushOldFP,
    /// The frame-pointer register for this architecture has just been
    /// set to the current stack location, and the word at FP is the
    /// previous FP value.
    ///
    /// The base of the frame is at `FP - fp_offset`. Note that only
    /// positive offsets from the base of the frame are allowed for
    /// `SaveReg`, but the FP register itself can point to any part
    /// of the frame.
    CreateFPFrame {
        /// The offset from the start of frame to the FP value (and
        /// current SP value).
        fp_offset: u8,
    },
    /// The stack slot at the given offset from the frame base has
    /// been used to save the given register.
    ///
    /// Given that `CreateFPFrame` has occurred first with some
    /// `fp_offset`, `SaveReg` with `frame_offset` indicates that the
    /// value of `reg` is saved on the stack at address `FP -
    /// fp_offset + frame_offset`.
    SaveReg {
        /// The offset from the start of frame to this register's
        /// stack location.
        frame_offset: u8,
        /// The saved register.
        reg: RealReg,
    },
}
