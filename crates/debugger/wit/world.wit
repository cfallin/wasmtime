package wasmtime:debugger@42.0.0;

/* TODO:

    - reflection:
      - defining new memories, tables, globals
      - instantiating modules into instances
    - debugger:
      - exception events
 */

world main {
  include wasi:cli/imports@0.2.6;
  import debuggee;
  export debugger;
}

interface debugger {
  use debuggee.{debuggee};

  /// Launch the debugger top-half (e.g., protocol server or UI)
  /// implemented by this component, given
  /// the provided interface to a debuggee.
  debug: func(d: debuggee);
}

interface debuggee {
  /// A debuggee consisting of one Store over which we have
  /// debugging control.
  ///
  /// A debuggee is always either "paused" or "running", and certain
  /// methods below are only available in one or the other state.
  resource debuggee {
    /// List all modules that exist in the Store.
    ///
    /// Usable in paused or running states.
    all-modules: func() -> list<module>;

    /// List of all instances that exist in the Store.
    ///
    /// Usable in paused or running states.
    all-instances: func() -> list<instance>;

    /// Force an interruption event in any running code.
    ///
    /// Usable in paused or running states. If invoked in
    /// the paused state, the next execution will immediately
    /// yield an "interrupted" event.
    interrupt: func();

    /// Single-step, returning a pollable that will yield an event
    /// when the single-step execution is complete.
    ///
    /// The `resumption` value indicates any mutations to
    /// perform to execution state as part of resuming:
    /// for example, injecting a call to another function,
    /// or throwing an exception, or forcing an early return
    /// from the current function.
    ///
    /// Usable in paused state; transitions to running state.
    /// Debuggee remains in running state until the returned
    /// pollable completes.
    ///
    /// If invoked while already running, causes a trap.
    single-step: func(resumption: resumption-value) -> event-pollable;

    /// Continue execution, returning a pollable that will
    /// yield an event when the resumed execution
    /// is complete.
    ///
    /// The `resumption` value indicates any mutations to
    /// perform to execution state as part of resuming:
    /// for example, injecting a call to another function,
    /// or throwing an exception, or forcing an early return
    /// from the current function.
    ///
    /// Usable in paused state; transitions to running state.
    /// Debuggee remains in running state until the returned
    /// pollable completes.
    ///
    /// If invoked while already running, causes a trap.
    continue: func(resumption: resumption-value) -> event-pollable;

    /// Get the current frame.
    ///
    /// Usable in paused state. If invoked while already
    /// running, causes a trap.
    frame: func() -> option<frame>;
  }

  /// A pollable that represents asynchronous execution of the
  /// debuggee until the next debug event pausing execution.
  ///
  /// When complete, yields the resulting debug event.
  resource event-pollable {
    /// Is this pollable ready?
    ready: func() -> bool;

    /// Consume this pollable, producing the resulting
    /// event. Blocks if not ready.
    finish: static func(self: event-pollable) -> result<event, error>;
  }

  /// A `resumption` value indicates how we want to continue
  /// execution after a pause.
  ///
  /// By default, if we are a "read-only" debugger, there is only
  /// one answer: with no mutation, according to the abstract
  /// Wasm machine semantics and current machine state.
  ///
  /// However, this interface also supports various kinds of mutations.
  /// For example, the debugger can ask to insert a call to an arbitrary
  /// Wasm function, it can force an early return from the current function,
  /// or it can throw an exception.
  ///
  /// This `resumption` value is orthogonal to the
  /// `continue` vs. `single-step` resume axis:
  /// the resumption value indicates whether we want to mutate
  /// the executing abstract machine's *state*, while the single-step
  /// vs. continue axis indicates how we want to step that machine
  /// forward from whatever state is indicated (i.e., one step or
  /// many until an event).
  variant resumption-value {
    /// Resume normally: do not alter the machine state.
    normal,
    /// Inject a call to a Wasm function at the current point, as-if
    /// the program contained a `call` instruction with the given
    /// values on the operand stack.
    ///
    /// Execution is subject to ordinary debugger events as with
    /// any other; e.g., the function we call may experience breakpoint
    /// pauses, may be single-stepped if we resume with `single-step`,
    /// etc.
    ///
    /// If the injected function call completes normally, an
    /// `injected-call-return` debug event is raised with the
    /// return value(s).
    inject-call(inject-call),
    /// Resume as-if an exception were thrown at the current point.
    throw-exception(wasm-exception),
    /// Force a return from the current function frame, with the given
    /// value(s) as return value(s).
    early-return(list<wasm-value>),
  }

  /// A function call to be injected upon resumption.
  record inject-call {
    callee: wasm-func,
    arguments: list<wasm-value>,
  }

  /// A debug event.
  variant event {
    /// Execution of the debuggee has completed.
    complete,
    /// A trap occurred in the debuggee. Execution
    /// is paused at the trap-point, and will terminate
    /// when resuming execution.
    trap,
    /// A breakpoint was hit in the debuggee, pausing
    /// execution.
    breakpoint,
    /// An interruption due to `debuggee.interrupt` occurred.
    interrupted,
    /// An injected call completed with return value(s).
    injected-call-return(list<wasm-value>),
  }

  resource instance {
    /// Get this instance's module.
    get-module: func() -> module;

    /// Get a memory from this instance's memory index space.
    get-memory: func(memory-index: u32) -> result<memory, error>;

    /// Get a global from this instance's global index space.
    get-global: func(global-index: u32) -> result<global, error>;

    /// Get a table from this instance's table index space.
    get-table: func(table-index: u32) -> result<table, error>;

    /// Get a function from this instance's function index space.
    get-func: func(func-index: u32) -> result<wasm-func, error>;

    /// Get a tag from this instance's tag index space.
    get-tag: func(tag-index: u32) -> result<wasm-tag, error>;

    /// Clone this handle.
    clone: func() -> wasm-tag;

    /// Get the unique ID of this instance (within the debuggee)
    /// to allow equality and hashing.
    unique-id: func() -> u32;
  }

  resource module {
    /// Get this module's source (Wasm bytecode) as a core Wasm module,
    /// if available.
    source: func() -> option<list<u8>>;

    /// Start a breakpoint edit session.
    edit-breakpoints: func() -> module-breakpoints;

    /// Clone this handle.
    clone: func() -> wasm-tag;

    /// Get the unique ID of this module to allow equality and hashing.
    unique-id: func() -> u32;
  }

  resource memory {
    /// Get the current memory size, in bytes.
    size-bytes: func() -> u32;

    /// Get the page size, in bytes.
    page-size-bytes: func() -> u32;

    /// Grow to a new size, in bytes.
    grow-to-bytes: func(new-size: u32) -> result<_, error>;

    /// Get a u8 (byte) at an address. Returns `none` if out-of-bounds.
    get-u8: func(addr: u32) -> result<u8, error>;
    /// Get a u16 (in little endian order) at an address.
    get-u16: func(addr: u32) -> result<u16, error>;
    /// Get a u32 (in little endian order) at an address.
    get-u32: func(addr: u32) -> result<u32, error>;
    /// Get a u64 (in little endian order) at an address.
    get-u64: func(addr: u32) -> result<u64, error>;

    /// Set a u8 (byte) at an address. Returns `none` if out-of-bounds.
    set-u8: func(addr: u32, value: u8) -> result<_, error>;
    /// Set a u16 (in little endian order) at an address.
    set-u16: func(addr: u32, value: u16) -> result<_, error>;
    /// Set a u32 (in little endian order) at an address.
    set-u32: func(addr: u32, value: u32) -> result<_, error>;
    /// Set a u64 (in little endian order) at an address.
    set-u64: func(addr: u32, value: u64) -> result<_, error>;

    /// Clone this handle.
    clone: func() -> wasm-tag;

    /// Get the unique ID of this memory to allow equality and hashing.
    unique-id: func() -> u32;
  }

  resource global {
    /// Get the value of this global.
    get: func() -> wasm-value;

    /// Set the value of this global.
    set: func(val: wasm-value) -> result<_, error>;

    /// Clone this handle.
    clone: func() -> wasm-tag;

    /// Get the unique ID of this memory to allow equality and hashing.
    unique-id: func() -> u32;
  }

  resource table {
    /// Get the current length of this table, in elements.
    len: func() -> u32;

    /// Get the value at the Nth slot.
    get-element: func(index: u32) -> result<wasm-value, error>;

    /// Set the value at the Nth slot.
    set-element: func(index: u32, val: wasm-value) -> result<_, error>;

    /// Clone this handle.
    clone: func() -> wasm-tag;

    /// Get the unique ID of this memory to allow equality and hashing.
    unique-id: func() -> u32;
  }

  resource wasm-func {
    /// Get the parameter types.
    params: func() -> list<wasm-type>;

    /// Get the result types.
    results: func() -> list<wasm-type>;

    /// Clone this handle.
    clone: func() -> wasm-tag;

    /// Get the unique ID of this function to allow equality and hashing.
    unique-id: func() -> u32;
  }

  resource wasm-exception {
    /// Get the tag of this exception.
    get-tag: func() -> wasm-tag;

    /// Get the payload values of this exception.
    get-values: func() -> list<wasm-value>;

    /// Clone this reference.
    clone: func() -> wasm-tag;

    /// Allocate a new exception.
    make: static func(
        tag: borrow<wasm-tag>,
        values: list<wasm-value>
    ) -> result<wasm-exception, error>;
  }

  resource wasm-tag {
    /// Get the parameter types.
    params: func() -> list<wasm-type>;

    /// Get the unique ID of this tag to allow equality and hashing.
    unique-id: func() -> u32;

    /// Clone this handle.
    clone: func() -> wasm-tag;

    /// Allocate a new tag.
    make: static func(params: list<wasm-type>) -> wasm-tag;
  }

  resource frame {
    /// Instance of this frame.
    instance: func() -> instance;

    /// Current PC in this frame's instance.
    pc: func() -> u32;

    /// Wasm locals.
    locals: func() -> list<wasm-value>;

    /// Operand stack.
    stack: func() -> list<wasm-value>;

    /// parent frame (the one that called this frame), if any.
    parent-frame: func() -> option<frame>;
  }

  resource module-breakpoints {
    /// Add a breakpoint.
    add-breakpoint: func(pc: u32) -> result<_, error>;
    /// Remove a breakpoint.
    remove-breakpoint: func(pc: u32) -> result<_, error>;
    /// Commit changes to breakpoints.
    ///
    /// Either `commit` or `cancel` must be called before
    /// this resource is dropped.
    commit: static func(self: module-breakpoints) -> result<_, error>;
    /// Cancel this edit session's changes.
    ///
    /// Either `commit` or `cancel` must be called before
    /// this resource is dropped.
    cancel: static func(self: module-breakpoints);
  }

  enum error {
    invalid-entity,
    invalid-pc,
    breakpoint-update,
    read-only,
    out-of-bounds,
  }

  resource wasm-value {
    get-type: func() -> wasm-type;
    unwrap-i32: func() -> u32;
    unwrap-i64: func() -> u64;
    unwrap-f32: func() -> f32;
    unwrap-f64: func() -> f64;
    unwrap-v128: func() -> list<u8>;
    unwrap-func: func() -> wasm-func;
    unwrap-exception: func() -> wasm-exception;

    clone: func() -> wasm-value;
  }

  variant wasm-type {
    wasm-i32,
    wasm-i64,
    wasm-f32,
    wasm-f64,
    wasm-v128,
    wasm-funcref,
    wasm-exnref,
    // TODO: GC structs and arrays
  }
}
